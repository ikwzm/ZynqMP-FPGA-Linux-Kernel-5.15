diff --git a/Documentation/devicetree/bindings/usb/ehci-xilinx.txt b/Documentation/devicetree/bindings/usb/ehci-xilinx.txt
new file mode 100644
index 000000000..4df7ad6e3
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/ehci-xilinx.txt
@@ -0,0 +1,21 @@
+Xilinx USB EHCI controller
+
+Required properties:
+- compatible: must be "xlnx,xps-usb-host-1.00.a"
+- reg: physical base address of the controller and length of memory mapped
+  region.
+- interrupts: The EHCI interrupt
+
+Optional properties:
+- xlnx,ext-vbus-valid: Use external VBUS
+- xlnx,support-usb-fs: Support for Full Speed USB
+- xlnx,use-phy-bus-pwr: Use phy bus power in USB
+
+Example:
+
+	xps_usb_host_0: usb@82400000 {
+		compatible = "xlnx,xps-usb-host-1.00.a";
+		interrupt-parent = <&xps_intc_0>;
+		interrupts = < 0 2 >;
+		reg = < 0x82400000 0x200 >;
+	} ;
diff --git a/drivers/usb/host/ehci-xilinx-of.c b/drivers/usb/host/ehci-xilinx-of.c
index 67a6ee8cb..3cefa3cb6 100644
--- a/drivers/usb/host/ehci-xilinx-of.c
+++ b/drivers/usb/host/ehci-xilinx-of.c
@@ -32,6 +32,8 @@
  * There are cases when the host controller fails to enable the port due to,
  * for example, insufficient power that can be supplied to the device from
  * the USB bus. In those cases, the messages printed here are not helpful.
+ *
+ * Return: Always return 0
  */
 static int ehci_xilinx_port_handed_over(struct usb_hcd *hcd, int portnum)
 {
@@ -46,11 +48,9 @@ static int ehci_xilinx_port_handed_over(struct usb_hcd *hcd, int portnum)
 		dev_warn(hcd->self.controller,
 			"Maybe your device is not a high speed device?\n");
 		dev_warn(hcd->self.controller,
-			"The USB host controller does not support full speed "
-			"nor low speed devices\n");
+			"USB host controller doesn't support FS/LS devices\n");
 		dev_warn(hcd->self.controller,
-			"You can reconfigure the host controller to have "
-			"full speed support\n");
+			"You can reconfigure host controller to support FS\n");
 	}
 
 	return 0;
@@ -112,6 +112,8 @@ static const struct hc_driver ehci_xilinx_of_hc_driver = {
  * host controller. Because the Xilinx USB host controller can be configured
  * as HS only or HS/FS only, it checks the configuration in the device tree
  * entry, and sets an appropriate value for hcd->has_tt.
+ *
+ * Return: zero on success, 'rv' value on failure
  */
 static int ehci_hcd_xilinx_of_probe(struct platform_device *op)
 {
@@ -196,6 +198,8 @@ static int ehci_hcd_xilinx_of_probe(struct platform_device *op)
  *
  * Remove the hcd structure, and release resources that has been requested
  * during probe.
+ *
+ * Return: Always return 0
  */
 static int ehci_hcd_xilinx_of_remove(struct platform_device *op)
 {
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index b97547841..636b10ec7 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -1941,6 +1941,13 @@ int xhci_bus_resume(struct usb_hcd *hcd)
 		}
 	}
 
+	/* After resuming back from suspend, the controller may not initiate
+	 * LFPS.U3_exit signalling if not given a delay after updating the
+	 * link from U3->U0. So, lets wait for atleast 1ms
+	 */
+	if (next_state == XDEV_U0)
+		mdelay(1);
+
 	/* poll for U0 link state complete, both USB2 and USB3 */
 	for_each_set_bit(port_index, &bus_state->bus_suspended, BITS_PER_LONG) {
 		sret = xhci_handshake(ports[port_index]->addr, PORT_PLC,
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 9d9ab7e35..cb6620166 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -677,6 +677,16 @@ struct xhci_stream_info *xhci_alloc_stream_info(struct xhci_hcd *xhci,
 		xhci_dbg(xhci, "Setting stream %d ring ptr to 0x%08llx\n",
 				cur_stream, (unsigned long long) addr);
 
+		if (xhci->quirks & XHCI_STREAM_QUIRK) {
+			/* dwc3 host controller has an issue where it doesn't
+			 * process BULK IN stream rings even after ringing
+			 * DoorBell, so setup a timer to aviod hang condition.
+			 */
+			timer_setup(&cur_ring->stream_timer,
+				    xhci_stream_timeout, 0);
+			cur_ring->xhci = xhci;
+		}
+
 		ret = xhci_update_stream_mapping(cur_ring, mem_flags);
 		if (ret) {
 			xhci_ring_free(xhci, cur_ring);
@@ -768,6 +778,10 @@ void xhci_free_stream_info(struct xhci_hcd *xhci,
 	for (cur_stream = 1; cur_stream < stream_info->num_streams;
 			cur_stream++) {
 		cur_ring = stream_info->stream_rings[cur_stream];
+
+		if (xhci->quirks & XHCI_STREAM_QUIRK)
+			del_timer_sync(&cur_ring->stream_timer);
+
 		if (cur_ring) {
 			xhci_ring_free(xhci, cur_ring);
 			stream_info->stream_rings[cur_stream] = NULL;
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index 972a44b2a..f7b2576d2 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/usb/of.h>
+#include <linux/usb/otg.h>
 
 #include "xhci.h"
 #include "xhci-plat.h"
@@ -30,6 +31,8 @@ static struct hc_driver __read_mostly xhci_plat_hc_driver;
 static int xhci_plat_setup(struct usb_hcd *hcd);
 static int xhci_plat_start(struct usb_hcd *hcd);
 
+static host_wakeup_t host_wakeup_fn;
+
 static const struct xhci_driver_overrides xhci_plat_overrides __initconst = {
 	.extra_priv_size = sizeof(struct xhci_plat_priv),
 	.reset = xhci_plat_setup,
@@ -96,6 +99,17 @@ static void xhci_plat_quirks(struct device *dev, struct xhci_hcd *xhci)
 	xhci->quirks |= XHCI_PLAT | priv->quirks;
 }
 
+static void host_wakeup_register(host_wakeup_t func)
+{
+	host_wakeup_fn = func;
+}
+
+static void host_wakeup_capable(struct device *dev, bool wakeup)
+{
+	if (host_wakeup_fn)
+		host_wakeup_fn(dev, wakeup);
+}
+
 /* called during probe() after chip reset completes */
 static int xhci_plat_setup(struct usb_hcd *hcd)
 {
@@ -184,6 +198,35 @@ static const struct of_device_id usb_xhci_of_match[] = {
 MODULE_DEVICE_TABLE(of, usb_xhci_of_match);
 #endif
 
+static int usb_otg_set_host(struct device *dev, struct usb_hcd *hcd, bool yes)
+{
+	int ret = 0;
+
+	hcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB3);
+	if (!IS_ERR_OR_NULL(hcd->usb_phy) && hcd->usb_phy->otg) {
+		if (yes) {
+			if (otg_set_host(hcd->usb_phy->otg, &hcd->self)) {
+				usb_put_phy(hcd->usb_phy);
+				goto disable_phy;
+			}
+		} else {
+			ret = otg_set_host(hcd->usb_phy->otg, NULL);
+			usb_put_phy(hcd->usb_phy);
+			goto disable_phy;
+		}
+
+	} else {
+		goto disable_phy;
+	}
+
+	return 0;
+
+disable_phy:
+	hcd->usb_phy = NULL;
+
+	return ret;
+}
+
 static int xhci_plat_probe(struct platform_device *pdev)
 {
 	const struct xhci_plat_priv *priv_match;
@@ -241,6 +284,9 @@ static int xhci_plat_probe(struct platform_device *pdev)
 			return ret;
 	}
 
+	/* Set the controller as wakeup capable */
+	device_set_wakeup_capable(&pdev->dev, true);
+
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 	pm_runtime_get_noresume(&pdev->dev);
@@ -299,6 +345,7 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	}
 
 	device_set_wakeup_capable(&pdev->dev, true);
+	host_wakeup_register(dwc3_host_wakeup_capable);
 
 	xhci->main_hcd = hcd;
 	xhci->shared_hcd = __usb_create_hcd(driver, sysdev, &pdev->dev,
@@ -323,6 +370,9 @@ static int xhci_plat_probe(struct platform_device *pdev)
 		if (device_property_read_bool(tmpdev, "quirk-broken-port-ped"))
 			xhci->quirks |= XHCI_BROKEN_PORT_PED;
 
+		if (device_property_read_bool(tmpdev, "xhci-reset-on-resume"))
+			xhci->quirks |= XHCI_RESET_ON_RESUME;
+
 		device_property_read_u32(tmpdev, "imod-interval-ns",
 					 &xhci->imod_interval);
 	}
@@ -365,6 +415,10 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	if (ret)
 		goto dealloc_usb2_hcd;
 
+	ret = usb_otg_set_host(&pdev->dev, hcd, true);
+	if (ret)
+		goto dealloc_usb2_hcd;
+
 	device_enable_async_suspend(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
@@ -417,6 +471,9 @@ static int xhci_plat_remove(struct platform_device *dev)
 	xhci->shared_hcd = NULL;
 	usb_phy_shutdown(hcd->usb_phy);
 
+	host_wakeup_register(NULL);
+	usb_otg_set_host(&dev->dev, hcd, false);
+
 	usb_remove_hcd(hcd);
 	usb_put_hcd(shared_hcd);
 
@@ -443,6 +500,15 @@ static int __maybe_unused xhci_plat_suspend(struct device *dev)
 	ret = xhci_priv_suspend_quirk(hcd);
 	if (ret)
 		return ret;
+
+	/* Inform dwc3 driver about the device wakeup capability */
+	if (device_may_wakeup(&hcd->self.root_hub->dev)) {
+		host_wakeup_capable(dev, true);
+		enable_irq_wake(hcd->irq);
+	} else {
+		host_wakeup_capable(dev, false);
+	}
+
 	/*
 	 * xhci_suspend() needs `do_wakeup` to know whether host is allowed
 	 * to do wakeup during suspend.
@@ -503,6 +569,9 @@ static int __maybe_unused xhci_plat_runtime_resume(struct device *dev)
 	struct usb_hcd  *hcd = dev_get_drvdata(dev);
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 
+	if (device_may_wakeup(&hcd->self.root_hub->dev))
+		disable_irq_wake(hcd->irq);
+
 	return xhci_resume(xhci, 0);
 }
 
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 73f2ff83e..2ea7058f6 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -868,7 +868,16 @@ static int xhci_td_cleanup(struct xhci_hcd *xhci, struct xhci_td *td,
 		/* set isoc urb status to 0 just as EHCI, UHCI, and OHCI */
 		if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
 			status = 0;
-		xhci_giveback_urb_in_irq(xhci, td, status);
+		if ((xhci->quirks & XHCI_STREAM_QUIRK) &&
+		    (ep_ring->stream_timeout_handler == true)) {
+			/* We get here if stream timer time-out and stop
+			 * command is issued. Send urb status as -EAGAIN
+			 * so that the same urb can be re-submitted.
+			 */
+			xhci_giveback_urb_in_irq(xhci, td, -EAGAIN);
+			ep_ring->stream_timeout_handler = false;
+		} else
+			xhci_giveback_urb_in_irq(xhci, td, status);
 	}
 
 	return 0;
@@ -1271,6 +1280,84 @@ void xhci_hc_died(struct xhci_hcd *xhci)
 		usb_hc_died(xhci_to_hcd(xhci));
 }
 
+/* This function is called when the stream ring timer gets timedout.
+ * dwc3 host controller has an issue where it doesn't process the BULK IN
+ * stream ring TD's(once in a while) even after ringing DoorBell for that
+ * stream ring. Because of this behaviour there will be no transfer events
+ * generated by the controller on the stream ring, resulting in the hang
+ * condition. xhci_stream_timeout() solves this issue by sending a stop
+ * command on the stream ring after stream timer gets timedout.
+ */
+void xhci_stream_timeout(struct timer_list *arg)
+{
+	struct xhci_hcd *xhci;
+	struct xhci_virt_ep *ep;
+	struct xhci_ring *ep_ring;
+	unsigned int slot_id, ep_index, stream_id;
+	struct xhci_td *td = NULL;
+	struct urb *urb = NULL;
+	struct urb_priv *urb_priv;
+	struct xhci_command *command;
+	unsigned long flags;
+	int i;
+
+	ep_ring = from_timer(ep_ring, arg, stream_timer);
+	xhci = ep_ring->xhci;
+
+	spin_lock_irqsave(&xhci->lock, flags);
+
+	if (!list_empty(&ep_ring->td_list)) {
+		td = list_entry(ep_ring->td_list.next, struct xhci_td, td_list);
+		urb = td->urb;
+		urb_priv = urb->hcpriv;
+
+		slot_id = urb->dev->slot_id;
+		ep_index = xhci_get_endpoint_index(&urb->ep->desc);
+		stream_id = ep_ring->stream_id;
+		ep = &xhci->devs[slot_id]->eps[ep_index];
+		ep_ring->stream_timeout_handler = true;
+
+		/* Delete the stream ring timer */
+		del_timer(&ep_ring->stream_timer);
+
+		for (i = 0; i < urb_priv->num_tds; i++) {
+			td = &urb_priv->td[i];
+			list_add_tail(&td->cancelled_td_list,
+					&ep->cancelled_td_list);
+		}
+
+		/* Queue a stop endpoint command, but only if this is
+		 * the first cancellation to be handled.
+		 */
+		if (!(ep->ep_state & EP_STOP_CMD_PENDING)) {
+			command = xhci_alloc_command(xhci, false,
+					GFP_ATOMIC);
+			if (!command) {
+				xhci_warn(xhci,
+					"%s: Failed to allocate command\n",
+						__func__);
+				spin_unlock_irqrestore(&xhci->lock, flags);
+				return;
+			}
+
+			ep->ep_state |= EP_STOP_CMD_PENDING;
+			ep->stop_cmd_timer.expires = jiffies +
+				XHCI_STOP_EP_CMD_TIMEOUT * HZ;
+			add_timer(&ep->stop_cmd_timer);
+			xhci_queue_stop_endpoint(xhci, command,
+					urb->dev->slot_id, ep_index, 0);
+			xhci_ring_cmd_db(xhci);
+		}
+
+		spin_unlock_irqrestore(&xhci->lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&xhci->lock, flags);
+	/* let the SCSI stack take care */
+	del_timer(&ep_ring->stream_timer);
+}
+
 /* Watchdog timer function for when a stop endpoint command fails to complete.
  * In this case, we assume the host controller is broken or dying or dead.  The
  * host may still be completing some other events, so we have to be careful to
@@ -2687,6 +2774,10 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 			td_num++;
 	}
 
+	if ((xhci->quirks & XHCI_STREAM_QUIRK) &&
+				(ep->ep_state & EP_HAS_STREAMS))
+		del_timer(&ep_ring->stream_timer);
+
 	/* Look for common error cases */
 	switch (trb_comp_code) {
 	/* Skip codes that require special handling depending on
@@ -3766,6 +3857,15 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	}
 
 	check_trb_math(urb, enqd_len);
+
+	if ((xhci->quirks & XHCI_STREAM_QUIRK) && (urb->stream_id > 0) &&
+				(usb_endpoint_dir_in(&urb->ep->desc) == 1)) {
+		/* Start the stream timer so that xhci_stream_timeout() can be
+		 * triggered if xhci is stuck while processing BULK IN streams.
+		 */
+		ring->stream_timeout_handler = false;
+		mod_timer(&ring->stream_timer, jiffies + 5 * HZ);
+	}
 	giveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,
 			start_cycle, start_trb);
 	return 0;
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 1fd2f6a85..d196731f3 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -185,7 +185,11 @@ int xhci_reset(struct xhci_hcd *xhci, u64 timeout_us)
 
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init, "// Reset the HC");
 	command = readl(&xhci->op_regs->command);
+#ifdef CONFIG_USB_DWC3_OTG
+	command |= CMD_LRESET;
+#else
 	command |= CMD_RESET;
+#endif
 	writel(command, &xhci->op_regs->command);
 
 	/* Existing Intel xHCI controllers require a delay of 1 mS,
@@ -198,7 +202,13 @@ int xhci_reset(struct xhci_hcd *xhci, u64 timeout_us)
 	if (xhci->quirks & XHCI_INTEL_HOST)
 		udelay(1000);
 
-	ret = xhci_handshake(&xhci->op_regs->command, CMD_RESET, 0, timeout_us);
+	ret = xhci_handshake(&xhci->op_regs->command,
+#ifdef CONFIG_USB_DWC3_OTG
+			CMD_LRESET,
+#else
+			CMD_RESET,
+#endif
+			0, timeout_us);
 	if (ret)
 		return ret;
 
@@ -1114,7 +1124,6 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 	int			retval = 0;
 	bool			comp_timer_running = false;
 	bool			pending_portevent = false;
-	bool			reinit_xhc = false;
 
 	if (!hcd->state)
 		return 0;
@@ -1132,10 +1141,10 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 
 	spin_lock_irq(&xhci->lock);
 
-	if (hibernated || xhci->quirks & XHCI_RESET_ON_RESUME || xhci->broken_suspend)
-		reinit_xhc = true;
+	if ((xhci->quirks & XHCI_RESET_ON_RESUME) || xhci->broken_suspend)
+		hibernated = true;
 
-	if (!reinit_xhc) {
+	if (!hibernated) {
 		/*
 		 * Some controllers might lose power during suspend, so wait
 		 * for controller not ready bit to clear, just as in xHC init.
@@ -1168,18 +1177,12 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 			spin_unlock_irq(&xhci->lock);
 			return -ETIMEDOUT;
 		}
+		temp = readl(&xhci->op_regs->status);
 	}
 
-	temp = readl(&xhci->op_regs->status);
-
-	/* re-initialize the HC on Restore Error, or Host Controller Error */
-	if (temp & (STS_SRE | STS_HCE)) {
-		reinit_xhc = true;
-		if (!xhci->broken_suspend)
-			xhci_warn(xhci, "xHC error in resume, USBSTS 0x%x, Reinit\n", temp);
-	}
-
-	if (reinit_xhc) {
+	/* If restore operation fails, re-initialize the HC during resume */
+	if ((temp & STS_SRE) || hibernated) {
+		
 		if ((xhci->quirks & XHCI_COMP_MODE_QUIRK) &&
 				!(xhci_all_ports_seen_u0(xhci))) {
 			del_timer_sync(&xhci->comp_mode_recovery_timer);
@@ -1635,12 +1638,9 @@ static int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flag
 	struct urb_priv	*urb_priv;
 	int num_tds;
 
-	if (!urb)
+	if (!urb || xhci_check_args(hcd, urb->dev, urb->ep,
+					true, true, __func__) <= 0)
 		return -EINVAL;
-	ret = xhci_check_args(hcd, urb->dev, urb->ep,
-					true, true, __func__);
-	if (ret <= 0)
-		return ret ? ret : -EINVAL;
 
 	slot_id = urb->dev->slot_id;
 	ep_index = xhci_get_endpoint_index(&urb->ep->desc);
@@ -1841,6 +1841,18 @@ static int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		goto err_giveback;
 	}
 
+	ep_index = xhci_get_endpoint_index(&urb->ep->desc);
+	ep = &xhci->devs[urb->dev->slot_id]->eps[ep_index];
+	ep_ring = xhci_urb_to_transfer_ring(xhci, urb);
+	if (!ep_ring) {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	/* Delete the stream timer */
+	if ((xhci->quirks & XHCI_STREAM_QUIRK) && (urb->stream_id > 0))
+		del_timer(&ep_ring->stream_timer);
+
 	i = urb_priv->num_tds_done;
 	if (i < urb_priv->num_tds)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
@@ -3357,7 +3369,7 @@ static int xhci_check_streams_endpoint(struct xhci_hcd *xhci,
 		return -EINVAL;
 	ret = xhci_check_args(xhci_to_hcd(xhci), udev, ep, 1, true, __func__);
 	if (ret <= 0)
-		return ret ? ret : -EINVAL;
+		return -EINVAL;
 	if (usb_ss_max_streams(&ep->ss_ep_comp) == 0) {
 		xhci_warn(xhci, "WARN: SuperSpeed Endpoint Companion"
 				" descriptor for ep 0x%x does not support streams\n",
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 0b22e8580..0646fef0f 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1638,6 +1638,9 @@ struct xhci_ring {
 	enum xhci_ring_type	type;
 	bool			last_td_was_short;
 	struct radix_tree_root	*trb_address_map;
+	struct timer_list	stream_timer;
+	bool			stream_timeout_handler;
+	struct xhci_hcd		*xhci;
 };
 
 struct xhci_erst_entry {
@@ -1906,6 +1909,7 @@ struct xhci_hcd {
 #define XHCI_EP_CTX_BROKEN_DCS	BIT_ULL(42)
 #define XHCI_SUSPEND_RESUME_CLKS	BIT_ULL(43)
 #define XHCI_RESET_TO_DEFAULT	BIT_ULL(44)
+#define XHCI_STREAM_QUIRK	BIT_ULL(45) /* FIXME this is wrong */
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
@@ -2091,6 +2095,8 @@ void xhci_free_container_ctx(struct xhci_hcd *xhci,
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
+typedef void (*host_wakeup_t)(struct device *dev, bool wakeup);
+void dwc3_host_wakeup_capable(struct device *dev, bool wakeup);
 int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, u64 timeout_us);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
@@ -2160,6 +2166,7 @@ void xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int slot_id,
 			       unsigned int ep_index, unsigned int stream_id,
 			       struct xhci_td *td);
 void xhci_stop_endpoint_command_watchdog(struct timer_list *t);
+void xhci_stream_timeout(struct timer_list *unused);
 void xhci_handle_command_timeout(struct work_struct *work);
 
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
@@ -2477,8 +2484,6 @@ static inline const char *xhci_decode_ctrl_ctx(char *str,
 	unsigned int	bit;
 	int		ret = 0;
 
-	str[0] = '\0';
-
 	if (drop) {
 		ret = sprintf(str, "Drop:");
 		for_each_set_bit(bit, &drop, 32)
@@ -2636,11 +2641,8 @@ static inline const char *xhci_decode_usbsts(char *str, u32 usbsts)
 {
 	int ret = 0;
 
-	ret = sprintf(str, " 0x%08x", usbsts);
-
 	if (usbsts == ~(u32)0)
-		return str;
-
+		return " 0xffffffff";
 	if (usbsts & STS_HALT)
 		ret += sprintf(str + ret, " HCHalted");
 	if (usbsts & STS_FATAL)
