--- linux-5.15.36/include/linux/usb/chipidea.h	2023-04-14 12:26:11.984957600 +0900
+++ linux-xlnx-2022.2/include/linux/usb/chipidea.h	2023-04-14 12:24:19.228290500 +0900
@@ -62,6 +62,7 @@
 #define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
 #define CI_HDRC_IMX_IS_HSIC		BIT(14)
 #define CI_HDRC_PMQOS			BIT(15)
+#define CI_HDRC_PHY_VBUS_CONTROL	BIT(16)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
--- linux-5.15.36/drivers/usb/chipidea/ci_hdrc_usb2.c	2023-04-14 12:26:08.312283300 +0900
+++ linux-xlnx-2022.2/drivers/usb/chipidea/ci_hdrc_usb2.c	2023-04-14 12:24:15.402281400 +0900
@@ -30,6 +30,7 @@
 
 static const struct ci_hdrc_platform_data ci_zynq_pdata = {
 	.capoffset	= DEF_CAPOFFSET,
+	.flags          = CI_HDRC_PHY_VBUS_CONTROL,
 };
 
 static const struct ci_hdrc_platform_data ci_zevio_pdata = {
@@ -64,6 +65,10 @@
 	if (match && match->data) {
 		/* struct copy */
 		*ci_pdata = *(struct ci_hdrc_platform_data *)match->data;
+		ci_pdata->usb_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy",
+					 0);
+		if (IS_ERR(ci_pdata->usb_phy))
+			return PTR_ERR(ci_pdata->usb_phy);
 	}
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
--- linux-5.15.36/drivers/usb/chipidea/core.c	2023-04-14 12:26:08.312283300 +0900
+++ linux-xlnx-2022.2/drivers/usb/chipidea/core.c	2023-04-14 12:24:15.402281400 +0900
@@ -324,7 +324,8 @@
 
 		ret = phy_power_on(ci->phy);
 		if (ret) {
-			phy_exit(ci->phy);
+			if (phy_exit(ci->phy) < 0)
+				dev_dbg(ci->dev, "phy exit failed\r\n");
 			return ret;
 		}
 	} else {
@@ -341,12 +342,20 @@
  */
 static void ci_usb_phy_exit(struct ci_hdrc *ci)
 {
+	int ret;
+
 	if (ci->platdata->flags & CI_HDRC_OVERRIDE_PHY_CONTROL)
 		return;
 
 	if (ci->phy) {
-		phy_power_off(ci->phy);
-		phy_exit(ci->phy);
+		ret = phy_power_off(ci->phy);
+		if (ret < 0)
+			dev_dbg(ci->dev, "phy poweroff failed\r\n");
+
+		ret = phy_exit(ci->phy);
+		if (ret < 0)
+			dev_dbg(ci->dev, "phy exit failed\r\n");
+
 	} else {
 		usb_phy_shutdown(ci->usb_phy);
 	}
@@ -709,13 +718,16 @@
 	if (usb_get_maximum_speed(dev) == USB_SPEED_FULL)
 		platdata->flags |= CI_HDRC_FORCE_FULLSPEED;
 
-	of_property_read_u32(dev->of_node, "phy-clkgate-delay-us",
-				     &platdata->phy_clkgate_delay_us);
+	if (of_property_read_u32(dev->of_node, "phy-clkgate-delay-us",
+				 &platdata->phy_clkgate_delay_us))
+		dev_dbg(dev, "Missing phy-clkgate-delay-us property\n");
 
 	platdata->itc_setting = 1;
 
-	of_property_read_u32(dev->of_node, "itc-setting",
-					&platdata->itc_setting);
+	if (of_property_read_u32(dev->of_node, "itc-setting",
+				 &platdata->itc_setting))
+		dev_dbg(dev, "Missing itc-setting property\n");
+
 
 	ret = of_property_read_u32(dev->of_node, "ahb-burst-config",
 				&platdata->ahb_burst_config);
--- linux-5.15.36/drivers/usb/chipidea/host.c	2023-04-14 12:26:08.312283300 +0900
+++ linux-xlnx-2022.2/drivers/usb/chipidea/host.c	2023-04-14 12:24:15.402281400 +0900
@@ -63,6 +63,14 @@
 		priv->enabled = enable;
 	}
 
+	if (ci->platdata->flags & CI_HDRC_PHY_VBUS_CONTROL &&
+			ci->usb_phy && ci->usb_phy->set_vbus) {
+		if (enable)
+			ci->usb_phy->set_vbus(ci->usb_phy, 1);
+		else
+			ci->usb_phy->set_vbus(ci->usb_phy, 0);
+	}
+
 	if (enable && (ci->platdata->phy_mode == USBPHY_INTERFACE_MODE_HSIC)) {
 		/*
 		 * Marvell 28nm HSIC PHY requires forcing the port to HS mode.
@@ -71,6 +79,7 @@
 		hw_port_test_set(ci, 5);
 		hw_port_test_set(ci, 0);
 	}
+
 	return 0;
 };
 
--- linux-5.15.36/drivers/usb/chipidea/otg.c	2023-04-14 12:26:08.312283300 +0900
+++ linux-xlnx-2022.2/drivers/usb/chipidea/otg.c	2023-04-14 12:24:15.402281400 +0900
@@ -168,6 +168,7 @@
 static void ci_handle_id_switch(struct ci_hdrc *ci)
 {
 	enum ci_role role = ci_otg_role(ci);
+	int ret;
 
 	if (role != ci->role) {
 		dev_dbg(ci->dev, "switching from %s to %s\n",
@@ -193,7 +194,10 @@
 			 */
 			hw_wait_vbus_lower_bsv(ci);
 
-		ci_role_start(ci, role);
+		ret = ci_role_start(ci, role);
+		if (ret < 0)
+			dev_dbg(ci->dev, "switching err %d\n", ret);
+
 		/* vbus change may have already occurred */
 		if (role == CI_ROLE_GADGET)
 			ci_handle_vbus_change(ci);
--- linux-5.15.36/drivers/usb/chipidea/otg_fsm.c	2023-04-14 12:26:08.312283300 +0900
+++ linux-xlnx-2022.2/drivers/usb/chipidea/otg_fsm.c	2023-04-14 12:24:15.402281400 +0900
@@ -471,6 +471,11 @@
 				return;
 			}
 		}
+
+		if (ci->platdata->flags & CI_HDRC_PHY_VBUS_CONTROL &&
+				ci->usb_phy && ci->usb_phy->set_vbus)
+			ci->usb_phy->set_vbus(ci->usb_phy, 1);
+
 		/* Disable data pulse irq */
 		hw_write_otgsc(ci, OTGSC_DPIE, 0);
 
@@ -480,6 +485,10 @@
 		if (ci->platdata->reg_vbus)
 			regulator_disable(ci->platdata->reg_vbus);
 
+		if (ci->platdata->flags & CI_HDRC_PHY_VBUS_CONTROL &&
+				ci->usb_phy && ci->usb_phy->set_vbus)
+			ci->usb_phy->set_vbus(ci->usb_phy, 0);
+
 		fsm->a_bus_drop = 1;
 		fsm->a_bus_req = 0;
 	}
--- linux-5.15.36/drivers/usb/chipidea/udc.c	2023-04-14 12:26:08.312283300 +0900
+++ linux-xlnx-2022.2/drivers/usb/chipidea/udc.c	2023-04-14 12:24:15.402281400 +0900
@@ -49,6 +49,8 @@
 	.wMaxPacketSize  = cpu_to_le16(CTRL_PAYLOAD_MAX),
 };
 
+static int reprime_dtd(struct ci_hdrc *ci, struct ci_hw_ep *hwep,
+		       struct td_node *node);
 /**
  * hw_ep_bit: calculates the bit number
  * @num: endpoint number
@@ -599,6 +601,12 @@
 
 		prevlastnode->ptr->next = cpu_to_le32(next);
 		wmb();
+
+		if (ci->rev == CI_REVISION_22) {
+			if (!hw_read(ci, OP_ENDPTSTAT, BIT(n)))
+				reprime_dtd(ci, hwep, prevlastnode);
+		}
+
 		if (hw_read(ci, OP_ENDPTPRIME, BIT(n)))
 			goto done;
 		do {
@@ -680,7 +688,8 @@
 		if ((TD_STATUS_ACTIVE & tmptoken) != 0) {
 			int n = hw_ep_bit(hwep->num, hwep->dir);
 
-			if (ci->rev == CI_REVISION_24)
+			if (ci->rev == CI_REVISION_24 ||
+			    ci->rev == CI_REVISION_22)
 				if (!hw_read(ci, OP_ENDPTSTAT, BIT(n)))
 					reprime_dtd(ci, hwep, node);
 			hwreq->req.status = -EALREADY;
