diff --git a/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c b/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
index 7607b516a..bde4859be 100644
--- a/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
+++ b/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
@@ -285,6 +285,14 @@ bool tpg_s_fourcc(struct tpg_data *tpg, u32 fourcc)
 	case V4L2_PIX_FMT_YVU422M:
 		tpg->buffers = 3;
 		fallthrough;
+	case V4L2_PIX_FMT_YUV444P:
+		tpg->vdownsampling[1] = 1;
+		tpg->vdownsampling[2] = 1;
+		tpg->hdownsampling[1] = 1;
+		tpg->hdownsampling[2] = 1;
+		tpg->planes = 3;
+		tpg->color_enc = TGP_COLOR_ENC_YCBCR;
+		break;
 	case V4L2_PIX_FMT_YUV422P:
 		tpg->vdownsampling[1] = 1;
 		tpg->vdownsampling[2] = 1;
@@ -445,6 +453,7 @@ bool tpg_s_fourcc(struct tpg_data *tpg, u32 fourcc)
 		tpg->twopixelsize[0] = 4;
 		tpg->twopixelsize[1] = 4;
 		break;
+	case V4L2_PIX_FMT_YUV444P:
 	case V4L2_PIX_FMT_YUV444M:
 	case V4L2_PIX_FMT_YVU444M:
 	case V4L2_PIX_FMT_YUV422M:
@@ -1196,6 +1205,7 @@ static void gen_twopix(struct tpg_data *tpg,
 		buf[1][1] = g_u_s;
 		break;
 
+	case V4L2_PIX_FMT_YUV444P:
 	case V4L2_PIX_FMT_YUV444M:
 		buf[0][offset] = r_y_h;
 		buf[1][offset] = g_u_s;
diff --git a/include/media/hdr-ctrls.h b/include/media/hdr-ctrls.h
new file mode 100644
index 000000000..61ca19573
--- /dev/null
+++ b/include/media/hdr-ctrls.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * These are the HDR controls for use with the extended control API.
+ *
+ * It turns out that these structs are not stable yet and will undergo
+ * more changes. So keep them private until they are stable and ready to
+ * become part of the official public API.
+ */
+
+#ifndef _HDR_CTRLS_H_
+#define _HDR_CTRLS_H_
+
+#include <linux/types.h>
+
+#define V4L2_CTRL_CLASS_METADATA 0x00b00000
+
+#define V4L2_CID_METADATA_BASE (V4L2_CTRL_CLASS_METADATA | 0x900)
+#define V4L2_CID_METADATA_CLASS (V4L2_CTRL_CLASS_METADATA | 1)
+
+#define V4L2_CID_METADATA_HDR (V4L2_CID_METADATA_BASE + 1)
+
+enum v4l2_eotf {
+	/*
+	 * EOTF values as per CTA 861.G spec (HDMI/DP).
+	 * If v4l2 driver is being implemented for other connectivity devices,
+	 * a conversion function must be implemented.
+	 */
+	V4L2_EOTF_TRADITIONAL_GAMMA_SDR,
+	V4L2_EOTF_TRADITIONAL_GAMMA_HDR,
+	V4L2_EOTF_SMPTE_ST2084,
+	V4L2_EOTF_BT_2100_HLG,
+};
+
+enum v4l2_hdr_type {
+	/*
+	 * This is for the v4l2_metadata_hdr structure.
+	 * MSB differentiates static (0) or dynamic (1) metadata.
+	 * Other 15 bits represent specific HDR standards.
+	 */
+
+	/* static HDR */
+	V4L2_HDR_TYPE_HDR10     = 0x0000,
+
+	/* dynamic HDR */
+	V4L2_HDR_TYPE_HDR10P    = 1 << 15 | V4L2_HDR_TYPE_HDR10,
+};
+
+/**
+ * struct v4l2_hdr10_payload - HDR Metadata Payload which matches CTA 861.G spec
+ *
+ * @eotf:				Electro-Optical Transfer Function (EOTF)
+ * @metadata_type:			Static_Metadata_Descriptor_ID
+ * @display_primaries:			Color Primaries of the Data
+ * @white_point:			White Point of Colorspace Data
+ * @max_mdl:				Max Mastering Display Luminance
+ * @min_mdl:				Min Mastering Display Luminance
+ * @max_cll:				Max Content Light Level
+ * @max_fall:				Max Frame Average Light Level
+ */
+struct v4l2_hdr10_payload {
+	__u8 eotf;
+	__u8 metadata_type;
+	struct {
+		__u16 x;
+		__u16 y;
+	} display_primaries[3];
+	struct {
+		__u16 x;
+		__u16 y;
+	} white_point;
+	__u16 max_mdl;
+	__u16 min_mdl;
+	__u16 max_cll;
+	__u16 max_fall;
+};
+
+/**
+ * struct v4l2_metadata_hdr - Container for HDR metadata
+ *
+ * @metadata_type:	HDR type
+ * @size:		Size of payload/metadata
+ * @payload:		Actual metadata
+ */
+struct v4l2_metadata_hdr {
+	__u16 metadata_type;
+	__u16 size;
+	/* Currently the largest extended HDR infoframe is 4000 bytes */
+	__u8 payload[4000];
+};
+
+#endif
diff --git a/include/media/media-entity.h b/include/media/media-entity.h
index 09737b478..c3abff449 100644
--- a/include/media/media-entity.h
+++ b/include/media/media-entity.h
@@ -205,6 +205,9 @@ struct media_pad {
  * @link_validate:	Return whether a link is valid from the entity point of
  *			view. The media_pipeline_start() function
  *			validates all links by calling this operation. Optional.
+ * @has_route:		Return whether a route exists inside the entity between
+ *			two given pads. Optional. If the operation isn't
+ *			implemented all pads will be considered as connected.
  *
  * .. note::
  *
@@ -218,6 +221,8 @@ struct media_entity_operations {
 			  const struct media_pad *local,
 			  const struct media_pad *remote, u32 flags);
 	int (*link_validate)(struct media_link *link);
+	bool (*has_route)(struct media_entity *entity, unsigned int pad0,
+			  unsigned int pad1);
 };
 
 /**
@@ -901,6 +906,9 @@ __must_check int media_graph_walk_init(
  */
 void media_graph_walk_cleanup(struct media_graph *graph);
 
+bool media_entity_has_route(struct media_entity *entity, unsigned int sink,
+			    unsigned int source);
+
 /**
  * media_graph_walk_start - Start walking the media graph at a
  *	given entity
